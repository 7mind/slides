\documentclass[usenames,dvipsnames]{beamer}
    \mode<presentation> {
    \usetheme{Montpellier}
    \usecolortheme{beaver}
    %\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
    \setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line
    \setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
    }

    \usepackage{graphicx} % Allows including images
    \usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
    \usepackage{minted}
    \usepackage{xcolor}
    \usepackage[utf8]{inputenc}
    \usepackage{pifont}    
    \usepackage{xspace} 
    \usepackage{newunicodechar}
    \newunicodechar{✪}{\ding{74}}

    \definecolor{mintedbackground}{rgb}{0.95,0.95,0.95}
    \newcommand{\code}[1]{\colorbox{lightgray}{\texttt{#1}}}
    \newcommand{\distage}{\texttt{distage}\xspace}


\newmintedfile[scalacode]{scala}{
bgcolor=mintedbackground,
fontfamily=tt,
linenos=true,
numberblanklines=true,
numbersep=5pt,
gobble=0,
frame=leftline,
framerule=0.4pt,
framesep=2mm,
funcnamehighlighting=true,
tabsize=4,
obeytabs=false,
mathescape=false
samepage=false, %with this setting you can force the list to appear on the same page
showspaces=false,
showtabs =false,
texcl=false,
}
    \setminted{fontsize=\footnotesize,baselinestretch=1}

    \usepackage {tikz}
    \usetikzlibrary {positioning}
    \graphicspath {{target/media/}}

    \title[\distage]{\distage: Modern Staged Dependency Injection for Scala}

    \institute[Septimal Mind Ltd]
    {
    Septimal Mind Ltd\\
    \medskip
    \textit{team@7mind.io}
    }
    \date{\today}

\begin{document}

% \begin{VerbatimOut}{ex-scala-roles.tmp}
% @RoleId("testservice") 
% class TestService[F[_] : Monad](http: HttpSrv[F]) 
%   extends IzService {
%     override def start(): Unit = http.start()
%     override def stop(): Unit = http.stop()
% }
% class TestPlugin extends PluginDef {
%   many[IzService].add[TestService[IO]]
% }
% object TestLauncher {
%   // run with 
%   // java test.jar test-service other-service
%   def main(args: Array[String]): Unit = IzRoleApp(args).main()
% }
% \end{VerbatimOut}

\begin{frame}
%\titlepage
\begin{figure}
\Huge 
\color{RubineRed} dist✪ge
\noindent
\rule{\linewidth}{1mm}
\Large Modern Staged Dependency Injection for Scala
\rule{\linewidth}{1mm}
\end{figure}

\begin{figure}
\color{RubineRed}
\normalsize Modular Functional Programming \\
with \\
Context Minimization \\
through \\
Garbage Collection
\end{figure}

\begin{figure}
\Large Septimal Mind Ltd \\
\medskip
\textit{team@7mind.io}
\end{figure}

\end{frame}

% - Modularity and it's importance 
% - DI-like mechanisms and their issues, especially in context of Scala (runtime DI is unreliable and does not integrate well with typesystem, compile-time DI may be not flexible enough) 
% - Why people get used to think that "DI does not compose with functional programming" why is it not correct and why alternatives are not good enough 
% - How we designed a staged DI which may work in both runtime and compile time 
% - How we may we improve reliability and get additional guarantees by exploiting staged approach 
% - Our integration with Scala typesystem 
% - how we support type tags for type lambdas and how we deal with implicits in runtime - and how may we write modular type-level code (so, we may use DI together with tagless final style, with IO, etc) 
% - Garbage-collecting DI and how may it help to significantly improve tests and deployments ( related slides: https://github.com/7mind/slides/blob/master/02-roles/target/roles.pdf )

\section{The problem: Dependency Injection and Functional Programming}

\begin{frame}
\frametitle{The motivation behind DI pattern and DI frameworks}
\begin{itemize}
\item Systems we work with may be represented as graphs. Nodes are components (usually instances), edges are references,
\item Graph transformation complexity grows non\-linearly with nodes count (need to add one constructor parameter, have to modify $k$ classes),
\item Graph composition has combinatoric complexity (need to run tests choosing between mock/production repositories and external APIs, have to write four configurations).
\end{itemize}

We have several possible options to address these problems:

\begin{itemize}
\item Singletons and Factories: solves tight coupling but expensive tests and refactorings,
\item Service Locator: bit less coupling but still expensive,
\item Dependency Injection: less invasive and supports isolation but requires more complex machinery.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{``DI doesn't compose with FP'': Problems}
\begin{itemize}
\item Typical DI framework is OOP oriented and does not support advanced concepts required for modern FP (typeclasses, higher\-kinded types),
\item Almost all the DI frameworks are working in runtime while many modern FP concepts are compile\-time by their nature,
\item Less guarantees: program which compiles correctly can break on wiring in runtime. After a huge delay,
\item Wiring is non-determenistic: Guice can spend several minutes trying to re\-instantiate heavy instance multiple times (once per dependency) then fail,
\item Wiring is opaque: it's hard or impossible to introspect the context. E.g. in Guice it's a real pain to close all the instantiated \texttt{Closeable}s.
      Adding missing values into the context (config injections) is not trivial as well.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{``DI doesn't compose with FP'': Notes}
\begin{itemize}
\item We have some compile\-time DI frameworks or mechanisms (see \texttt{MacWire}) allowing us to implement DI as pattern 
      though purely compile\-time tools are not convenient when we have to deal with purely runtime entities 
      (like plugins and config values),
\item Graph composition problem is not addressed by any existing tool.
\end{itemize}
\end{frame}

\section{\distage: Staged DI for Scala}

\begin{frame}
\frametitle{DI implementations are broken\dots}
\dots so we may build better one, which must:
\begin{itemize}
\item be well\-integrated with type system of our target language (higher\-kinded types, implicits, typeclasses),
\item allow us to introspect and modify our context on the fly,
\item be able to detect as many as possible problems quickly, better during compilation,
\item give us a way to stop making atomic or conditional contexts.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Staged approach}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Compile-Time and Runtime DI}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Extension: Configuration Support}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Pattern: Plan Completion}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Principle Behind: PPER}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\subsection{Garbage Collector and its Benefits}

\begin{frame}
\frametitle{Garbage Collector}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Context Minimization}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Context Minimization for Tests}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Context Minimization for Deployment}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\subsection{Scala Typesystem Integration: Fusional Programming}

\begin{frame}
\frametitle{Kind-Polymorphic Type Tags}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Typeclass instance injection (Implicit Injection)}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Lambda injection and Parameter Magnet}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Code example: IO Injection}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Code example: Tagless Final Style}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\subsection{Convenience features}

\begin{frame}
\frametitle{Dynamic Plugins}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Tags}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Plan Introspection}
\begin{itemize}
\item 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Trait Completion}
\begin{itemize}
\item Runtime and Compile-time.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Factory Methods (Assisted Injection)}
\begin{itemize}
\item Useful for Akka, lot more convenient than Guice,
\item Runtime and Compile-time.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Status and things to do}
\distage is:
\begin{itemize}
\item ready to use,
\item in real production,
\item all Runtime APIs are available,
\item Compile-time verification, trait completion, assisted injections and lambda injections are available.
\end{itemize}
\vspace{0.3cm}
Our plans:
\begin{itemize}
\item Refactor Roles API,
\item Support running Producer within a monad (IO),
\item Support Scala.js,
\item Support optional isolated classloaders (in foreseeable future),
\item Publish compile-time Producer,
\item Check our GitHub: https://github.com/pshirshov/izumi-r2.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\distage is just a part of our stack}
We have a vision backed by our tools:
\begin{itemize}
\item Idealingua: transport and codec agnostic gRPC alternative with rich modeling language,
\item LogStage: zero-cost logging framework,
\item \textit{Fusional Programming and Design} guidelines. We love both FP and OOP,
\item \textit{Continous Delivery} guidelines for Role-based process, 
\item \textit{Percept-Plan-Execute} Generative Programming approach, abstract machine and computational model.
Addresses Project Planning (see Operations Research). Examples: orchestration, build systems.
\end{itemize}

Altogether these things already allowed us to significantly reduce development costs and
delivery time for our client.\newline

More slides to follow.
\end{frame}

\begin{frame}
\frametitle{Teaser: LogStage}
\end{frame}

\begin{frame}
\frametitle{Teaser: Idealingua}
\end{frame}


\begin{frame}
    \frametitle{Thank you for your attention}

    \begin{center}
      https://izumi.7mind.io/

      We're looking for clients, contributors, adopters and colleagues ;)
    \end{center}

    About the author:
    \begin{itemize}
        \item coding for 18 years, 10 years of hands-on commercial engineering experience,
        \item has been leading a cluster orchestration team in Yandex, ``the Russian Google'',
        \item implemented ``\textit{Interstellar Spaceship}'' -- an orchestration solution to manage 50K+ physical machines across 6 datacenters,
        \item Owns an Irish R\&D company, https://7mind.io,
        \item Contacts: team@7mind.io,
        \item Github: https://github.com/pshirshov
    \end{itemize}
\end{frame}

\end{document}
